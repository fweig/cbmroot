diff --git a/MQ/monitor/CMakeLists.txt b/MQ/monitor/CMakeLists.txt
index e8366b2b..56ec47c9 100644
--- a/MQ/monitor/CMakeLists.txt
+++ b/MQ/monitor/CMakeLists.txt
@@ -3,7 +3,7 @@ configure_file(${CMAKE_CURRENT_SOURCE_DIR}/startMQSamplerT0Monitor2020.sh.in ${C
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/startMQSamplerTofMonitor2020.sh.in ${CMAKE_BINARY_DIR}/bin/MQ/topologies/startMQSamplerTofMonitor2020.sh)
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/startMQSamplerT0Monitor2021.sh.in ${CMAKE_BINARY_DIR}/bin/MQ/topologies/startMQSamplerT0Monitor2021.sh)
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/startMQSamplerTofMonitor2021.sh.in ${CMAKE_BINARY_DIR}/bin/MQ/topologies/startMQSamplerTofMonitor2021.sh)
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/startMQSamplerPsdMonitor2021.sh.in ${CMAKE_BINARY_DIR}/bin/MQ/topologies/startMQSamplerPsdMonitor2021.sh)
+#configure_file(${CMAKE_CURRENT_SOURCE_DIR}/startMQSamplerPsdMonitor2021.sh.in ${CMAKE_BINARY_DIR}/bin/MQ/topologies/startMQSamplerPsdMonitor2021.sh)
 
 
 set(INCLUDE_DIRECTORIES
@@ -131,5 +131,5 @@ set(DEPENDENCIES
   RHTTP
 )
 #GENERATE_LIBRARY()
-GENERATE_EXECUTABLE()
+#GENERATE_EXECUTABLE()
 
diff --git a/core/data/CMakeLists.txt b/core/data/CMakeLists.txt
index 95559844..4814515d 100644
--- a/core/data/CMakeLists.txt
+++ b/core/data/CMakeLists.txt
@@ -139,6 +139,6 @@ GENERATE_LIBRARY()
 # Install file which has no corresponding source file
 Install(FILES 
         CbmDefs.h rich/CbmRichRingLight.h base/CbmDigiVector.h
-        raw/bitmask_operators.hpp raw/PsdGbtDataFormat.h
+        raw/bitmask_operators.hpp raw/PsdGbtDataFormatV100.h
         DESTINATION include
        )
diff --git a/core/data/raw/PsdGbtReader.cxx b/core/data/raw/PsdGbtReader.cxx
index 421f61ad..c0de94d4 100644
--- a/core/data/raw/PsdGbtReader.cxx
+++ b/core/data/raw/PsdGbtReader.cxx
@@ -7,122 +7,198 @@
 
 #include "PsdGbtReader.h"
 
-#include <cstdint>  // for uint16_t, uint64_t, uint32_t
-
 namespace PsdData {
 
   PsdGbtReader::~PsdGbtReader() {
-    EvHdrAb.clear();
-    EvHdrAc.clear();
+    MsHdr.clear();
+    PackHdr.clear();
     HitHdr.clear();
     HitData.clear();
+    VectPackHdr.clear();
     VectHitHdr.clear();
     VectHitData.clear();
   }
 
-  void PsdGbtReader::ReadEventHeaderAbFles() {
-    EvHdrAb.clear();
-    buffer_shift = 0;
-    EvHdrAb.ulMicroSlice =
-      (buffer[gbt_word_index] >> buffer_shift) & 0xffffffffffffffff;
-    gbt_word_index++;
+  void PsdGbtReader::ReadMsHeader() {
+    MsHdr.clear();
+    save_buffer.push_back(std::to_string(buffer[word_index]));
+    save_buffer.push_back(std::to_string(buffer[word_index+1]));
 
-    buffer_shift        = 0;
-    EvHdrAb.uHitsNumber = (buffer[gbt_word_index] >> buffer_shift)
-                          & (((static_cast<uint32_t>(1)) << EvHdrAb.HNs) - 1);
-    buffer_shift += EvHdrAb.HNs;
-    EvHdrAb.uMagicWordAB = (buffer[gbt_word_index] >> buffer_shift)
-                           & (((static_cast<uint32_t>(1)) << EvHdrAb.MWs) - 1);
-    gbt_word_index++;
-
-    if (PrintOut) EvHdrAb.printout();
+    MsHdr.uMagicWord = (buffer[word_index] >> 32) & 0xff;
+    MsHdr.ulMicroSlice = ((buffer[word_index] & 0xffffff) << 40) | (buffer[word_index+1] & 0xffffffffff);
+    word_index+=2;
+
+    if(print) MsHdr.printout();
   }
 
-  void PsdGbtReader::ReadEventHeaderAcFles() {
-    EvHdrAc.clear();
-    buffer_shift     = 0;
-    EvHdrAc.uAdcTime = (buffer[gbt_word_index] >> buffer_shift)
-                       & (((static_cast<uint64_t>(1)) << EvHdrAc.TMs) - 1);
-    gbt_word_index++;
+  void PsdGbtReader::ReadPackHeader() {
+    PackHdr.clear();
+    save_buffer.push_back(std::to_string(buffer[word_index]));
+    save_buffer.push_back(std::to_string(buffer[word_index+1]));
+
+    buffer_shift        = 0;
+    PackHdr.uHitsNumber = (buffer[word_index] >> buffer_shift)
+                          & (((static_cast<uint16_t>(1)) << PackHdr.HNs) - 1);
+    buffer_shift += PackHdr.HNs+PackHdr.E0s;
+    PackHdr.uLinkIndex  = (buffer[word_index] >> buffer_shift)
+                          & (((static_cast<uint16_t>(1)) << PackHdr.LIs) - 1);
+    buffer_shift += PackHdr.LIs;
+    PackHdr.uMagicWord  = (buffer[word_index] >> buffer_shift)
+                          & (((static_cast<uint16_t>(1)) << PackHdr.MWs) - 1);
+    word_index++;
 
     buffer_shift = 0;
-    EvHdrAc.uPacketVersion =
-      (buffer[gbt_word_index] >> buffer_shift)
-      & (((static_cast<uint32_t>(1)) << EvHdrAc.PVs) - 1);
-    buffer_shift += EvHdrAc.PVs;
-    EvHdrAc.uMagicWordAC = (buffer[gbt_word_index] >> buffer_shift)
-                           & (((static_cast<uint32_t>(1)) << EvHdrAc.MWs) - 1);
-    gbt_word_index++;
-
-    if (PrintOut) EvHdrAc.printout();
+
+    PackHdr.uAdcTime    = (buffer[word_index] >> buffer_shift)
+                          & (((static_cast<uint64_t>(1)) << PackHdr.TMs) - 1);
+    buffer_shift += PackHdr.TMs;
+    PackHdr.uTotalWords = (buffer[word_index] >> buffer_shift)
+                          & (((static_cast<uint32_t>(1)) << PackHdr.TWs) - 1);
+    word_index++;
+
+    if(print) PackHdr.printout();
   }
 
-  void PsdGbtReader::ReadHitHeaderFles() {
+  void PsdGbtReader::ReadHitHeader() {
     HitHdr.clear();
-    buffer_shift      = 0;
-    HitHdr.uZeroLevel = (buffer[gbt_word_index] >> buffer_shift)
-                        & (((static_cast<uint32_t>(1)) << HitHdr.ZLs) - 1);
+    save_buffer.push_back(std::to_string(buffer[word_index]));
+    save_buffer.push_back(std::to_string(buffer[word_index+1]));
+
+    buffer_shift      = 24;
+    HitHdr.uWfmWords  = (buffer[word_index] >> buffer_shift)
+                        & (((static_cast<uint16_t>(1)) << HitHdr.WWs) - 1);
+    buffer_shift += HitHdr.WWs;
+    HitHdr.uHitChannel = (buffer[word_index] >> buffer_shift)
+                           & (((static_cast<uint32_t>(1)) << HitHdr.HCs) - 1);
+    word_index++;
+
+    buffer_shift       = 0;
+    HitHdr.uZeroLevel  = (buffer[word_index] >> buffer_shift)
+                         & (((static_cast<uint32_t>(1)) << HitHdr.ZLs) - 1);
     buffer_shift += HitHdr.ZLs;
-    HitHdr.uSignalCharge = (buffer[gbt_word_index] >> buffer_shift)
+    HitHdr.uSignalCharge = (buffer[word_index] >> buffer_shift)
                            & (((static_cast<uint32_t>(1)) << HitHdr.SCs) - 1);
-    gbt_word_index++;
+    word_index++;
 
-    buffer_shift       = 0;
-    HitHdr.uHitChannel = (buffer[gbt_word_index] >> buffer_shift)
-                         & (((static_cast<uint32_t>(1)) << HitHdr.HCs) - 1);
-    buffer_shift += HitHdr.HCs;
-    HitHdr.uWfmPoints = (buffer[gbt_word_index] >> buffer_shift)
-                        & (((static_cast<uint32_t>(1)) << HitHdr.WPSs) - 1);
-    gbt_word_index++;
-
-    if (PrintOut) HitHdr.printout();
+    if(print) HitHdr.printout();
   }
 
-  void PsdGbtReader::ReadHitDataFles() {
-    HitData.clear();
-    buffer_shift = 64;
-    for (int wfm_pt_iter = 0; wfm_pt_iter < HitHdr.uWfmPoints; wfm_pt_iter++) {
-      buffer_shift -= HitData.WPs;
-      uint16_t wfm_point = (buffer[gbt_word_index] >> buffer_shift)
-                           & (((static_cast<uint32_t>(1)) << HitData.WPs) - 1);
-      HitData.uWfm.push_back(wfm_point);
-      if (buffer_shift == 0) {
-        gbt_word_index += 2;
-        buffer_shift = 64;
-      }
-    }
-
-    if (PrintOut) HitData.printout();
+  void PsdGbtReader::ReadHitData() {
+    save_buffer.push_back(std::to_string(buffer[word_index]));
+    save_buffer.push_back(std::to_string(buffer[word_index+1]));
+
+    uint16_t wfm_point = 0;
+    wfm_point = ((buffer[word_index] >> 8) & 0xffff);
+    HitData.uWfm.push_back(wfm_point);
+    wfm_point = ((buffer[word_index] & 0xff) << 8) | ((buffer[word_index+1] >> 32) & 0xff);
+    HitData.uWfm.push_back(wfm_point);
+    word_index++;
+
+    wfm_point = ((buffer[word_index] >> 16) & 0xffff);
+    HitData.uWfm.push_back(wfm_point);
+    wfm_point = (buffer[word_index] & 0xffff);
+    HitData.uWfm.push_back(wfm_point);
+    word_index++;
   }
 
-  int PsdGbtReader::ReadEventFles() {
-    bool IsAbHeaderInMessage = false;
-    bool IsAcHeaderInMessage = false;
+  int PsdGbtReader::ReadMs() {
+
+
+
+
+
+
+
+		save_buffer.clear();
+		bool word_is_Ms_header = false;
+
+		while(!word_is_Ms_header)
+		{	
+			ReadMsHeader();
+			word_is_Ms_header = (MsHdr.uMagicWord == 0xa0);
+
+			if(word_is_Ms_header) { ms_hdrs_read++; break; }
+			else words_missed++;
+		}
+
+		bool word_is_Pack_header = true;
+		VectPackHdr.clear();
+		VectHitHdr.clear();
+		VectHitData.clear();
+
+		while(word_is_Pack_header)
+		{
+			ReadPackHeader();
+
+			if(PackHdr.uMagicWord != 0xb)
+			{
+				word_is_Pack_header = false;
+				if(print) printf("End of microslice\n");
+				word_index-=2;
+				save_buffer.pop_back();
+				break; //return 1; //TODO uncomment me
+			}
+			else
+			{
+				//hit loop
+				for(int hit_iter = 0; hit_iter < PackHdr.uHitsNumber; hit_iter++) 
+				{
+					ReadHitHeader();
+					if(HitHdr.uHitChannel > 32) return 2;
+
+					VectHitHdr.emplace_back(HitHdr);
+					VectPackHdr.emplace_back(PackHdr); //for convenient use of uAdcTime with each hit
+
+					HitData.clear();
+					if(HitHdr.uWfmWords > 10) return 3;
+					for(int wfm_word_iter = 0; wfm_word_iter < HitHdr.uWfmWords-1; wfm_word_iter++)
+						ReadHitData();
+
+					VectHitData.emplace_back(HitData);
+					if(print) HitData.printout();
+
+				} //hit loop
+			}
+
+		}
+		ms_ends_read++;
+
+		return 0;
+
+}
+
+
+
+
+
+void PsdGbtReader::PrintSaveBuff()
+{
+	for (auto & elem : save_buffer) printf("%s\n", elem.c_str());
+}
+
+void PsdGbtReader::PrintOut()
+{
+	MsHdr.printout();
+	for(int hit_iter = 0; hit_iter < (int)VectPackHdr.size(); hit_iter++) 
+	{
+		VectPackHdr.at(hit_iter).printout();
+		VectHitHdr.at(hit_iter).printout();
+		VectHitData.at(hit_iter).printout();
+	}
+	PackHdr.printout();
+
+}
+
+
+
+
+
+
+
 
-    ReadEventHeaderAbFles();
-    ReadEventHeaderAcFles();
-    IsAbHeaderInMessage = (EvHdrAb.uMagicWordAB == 171);
-    IsAcHeaderInMessage = (EvHdrAc.uMagicWordAC == 172);
 
-    if (IsAbHeaderInMessage && IsAcHeaderInMessage) {
-      VectHitHdr.clear();
-      VectHitData.clear();
 
-      //hit loop
-      for (int hit_iter = 0; hit_iter < EvHdrAb.uHitsNumber; hit_iter++) {
-        ReadHitHeaderFles();
-        VectHitHdr.push_back(HitHdr);
-        ReadHitDataFles();
-        VectHitData.push_back(HitData);
 
-        if (VectHitHdr.at(hit_iter).uWfmPoints != 8) { return 2; }
-      }  //hit loop
 
-      if (EvHdrAb.uHitsNumber != VectHitHdr.size()) { return 3; }
-    } else {
-      return 1;
-    }
 
-    return 0;
-  }
 }  // namespace PsdData
diff --git a/core/data/raw/PsdGbtReader.h b/core/data/raw/PsdGbtReader.h
index bfac3d37..d4c14a8b 100644
--- a/core/data/raw/PsdGbtReader.h
+++ b/core/data/raw/PsdGbtReader.h
@@ -8,51 +8,63 @@
 #ifndef PSD_GBT_READER_H_
 #define PSD_GBT_READER_H_
 
+#include <cstdint>   // for uint16_t, uint64_t, uint32_t
 #include <stdint.h>  // for uint64_t, uint32_t
 #include <vector>    // for vector
+#include <string>    // for string
 
-#include "PsdGbtDataFormat.h"  // for PsdHitData, PsdHitHeader, PsdEventHead...
-
+#include "PsdGbtDataFormatV100.h"
 namespace PsdData {
-  class PsdGbtReader {
 
+  class PsdGbtReader {
   public:
     PsdGbtReader() {};
-    PsdGbtReader(const uint64_t* input) {
+    PsdGbtReader(const uint64_t* input, uint8_t data_vers) {
       buffer         = input;
-      gbt_word_index = 0;
+      data_version   = data_vers;
     }
 
-    ~PsdGbtReader();
+    void SetInput(const uint64_t* input, uint8_t data_vers) {
+      buffer         = input;
+      data_version   = data_vers;
+    }
+    std::vector<std::string> save_buffer;
 
-    PsdEventHeaderAB EvHdrAb;
-    PsdEventHeaderAC EvHdrAc;
-    PsdHitHeader HitHdr;
-    PsdHitData HitData;
+    struct PsdMsHeader MsHdr;
+    struct PsdPackHeader PackHdr;
+    struct PsdHitHeader HitHdr;
+    struct PsdHitData HitData;
 
-    std::vector<PsdHitHeader> VectHitHdr;
-    std::vector<PsdHitData> VectHitData;
+    std::vector<struct PsdPackHeader> VectPackHdr;
+    std::vector<struct PsdHitHeader> VectHitHdr;
+    std::vector<struct PsdHitData> VectHitData;
 
-    void SetInput(const uint64_t* input) {
-      buffer         = input;
-      gbt_word_index = 0;
-    }
-    void SetPrintOutMode(bool mode) { PrintOut = mode; }
-    void ReadEventHeaderAbFles();
-    void ReadEventHeaderAcFles();
-    void ReadHitHeaderFles();
-    void ReadHitDataFles();
-    int ReadEventFles();
+    void ReadMsHeader();
+    void ReadPackHeader();
+    void ReadHitHeader();
+    void ReadHitData();
+    int  ReadMs();
+
+    void PrintSaveBuff();
+    void PrintOut();
 
     //Getters
-    uint32_t GetTotalGbtWordsRead() { return gbt_word_index; }
+    uint32_t GetTotalGbtWordsRead() { return word_index; }
+
+    void SetPrintOutMode(bool mode) { print = mode; }
+    ~PsdGbtReader();
+
+    int word_index = 0;
+    int words_missed = 0;
+    int ms_hdrs_read = 0;
+    int ms_ends_read = 0;
 
   private:
     const uint64_t* buffer;
+    uint8_t data_version;
 
-    bool PrintOut           = false;
-    uint32_t gbt_word_index = 0;
-    int buffer_shift        = 0;
+    bool print = false;
+    int buffer_shift = 0;
   };
 }  // namespace PsdData
 
diff --git a/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.cxx b/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.cxx
index 2c4d8254..76d1fef0 100644
--- a/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.cxx
+++ b/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.cxx
@@ -358,44 +358,47 @@ Bool_t CbmMcbm2018MonitorAlgoPsd::ProcessMs(const fles::Timeslice& ts,
     }
   }
 
-  PsdData::PsdGbtReader PsdReader(pInBuff);
+  PsdData::PsdGbtReader PsdReader(pInBuff, 1);
   if (fair::Logger::Logging(fair::Severity::debug)) PsdReader.SetPrintOutMode(true);
-  if (uSize > 0) {
+  // every 80bit gbt word is decomposed into two 64bit words
+  if (uSize > 1) { 
     while (PsdReader.GetTotalGbtWordsRead() < uNbMessages) {
-      int ReadResult = PsdReader.ReadEventFles();
-      if (PsdReader.EvHdrAb.uHitsNumber > kuNbChanPsd) {
-        LOG(error) << "too many triggered channels! In header: "
-                   << PsdReader.EvHdrAb.uHitsNumber
-                   << " in PSD: " << GetNbChanPsd();
-        break;
-      }
+      int ReadResult = PsdReader.ReadMs();
 
       if (ReadResult == 0) {
         fuCountsLastSecond++;
-        fhAdcTime->Fill(PsdReader.EvHdrAc.uAdcTime);
         fuReadEvtCntInMs++;
 
         //hit loop
-        for (int hit_iter = 0; hit_iter < PsdReader.EvHdrAb.uHitsNumber;
-             hit_iter++) {
-          UInt_t uHitChannel = PsdReader.VectHitHdr.at(hit_iter).uHitChannel;
-          UInt_t uSignalCharge =
-            PsdReader.VectHitHdr.at(hit_iter).uSignalCharge;
-          UInt_t uZeroLevel = PsdReader.VectHitHdr.at(hit_iter).uZeroLevel;
+        for (uint64_t hit_iter = 0; hit_iter < PsdReader.VectHitHdr.size(); hit_iter++) {
+          if(PsdReader.VectPackHdr.size() != PsdReader.VectHitHdr.size()){
+          LOG(error) << "Different vector headers sizes!"
+                     << " in VectPackHdr " << PsdReader.VectPackHdr.size() 
+                     << " in VectHitHdr " << PsdReader.VectHitHdr.size() << "\n";
+            break;
+          }
+
+          uint8_t uHitChannel = PsdReader.VectHitHdr.at(hit_iter).uHitChannel;
+          uint8_t uLinkIndex = PsdReader.VectPackHdr.at(hit_iter).uLinkIndex;
+          uint32_t uSignalCharge = PsdReader.VectHitHdr.at(hit_iter).uSignalCharge;
+          uint16_t uZeroLevel = PsdReader.VectHitHdr.at(hit_iter).uZeroLevel;
+          //double dHitTime = (double) fulCurrentMsIdx + PsdReader.VectPackHdr.at(hit_iter).uAdcTime*12.5; //in ns
+          double dHitTime = PsdReader.MsHdr.ulMicroSlice*1000. + PsdReader.VectPackHdr.at(hit_iter).uAdcTime*12.5; //in ns
           std::vector<uint16_t> uWfm = PsdReader.VectHitData.at(hit_iter).uWfm;
 
-          if (uHitChannel >= kuNbChanPsd)  //uHitChannel numerated from 0
-          {
+          fhAdcTime->Fill(PsdReader.VectPackHdr.at(hit_iter).uAdcTime);
+
+          //uHitChannel numerated from 0
+          if (uHitChannel >= kuNbChanPsd){
             LOG(error) << "hit channel number out of range! channel index: "
                        << uHitChannel << " max: " << GetNbChanPsd();
             break;
           }
-          //Hit header
+
+          //Pack header
           fhHitChargeMap->Fill(uHitChannel, uSignalCharge);
           fhHitMapEvo->Fill(uHitChannel, fdMsTime - fdStartTime);
-          fhChanHitMapEvo->Fill(
-            uHitChannel,
-            fdMsTime - fdStartTime);  //should be placed map(channel)
+          fhChanHitMapEvo->Fill(uHitChannel, fdMsTime - fdStartTime);  //should be placed map(channel)
 
           if (fbMonitorChanMode) {
 
@@ -403,18 +406,27 @@ Bool_t CbmMcbm2018MonitorAlgoPsd::ProcessMs(const fles::Timeslice& ts,
             fvhHitZeroLevelChan[uHitChannel]->Fill(uZeroLevel);
 
             //Hit data
-            uint16_t uHitAmlpitude = 0;
-            UInt_t uHitChargeWfm   = 0;
+            int32_t iHitAmlpitude = 0;
+            int32_t iHitChargeWfm = 0;
             if (fbMonitorWfmMode) fvhHitWfmChan[uHitChannel]->Reset();
             if (fbMonitorFitMode) fvhHitFitWfmChan[uHitChannel]->Reset();
-            for (UInt_t wfm_iter = 0; wfm_iter < uWfm.size(); wfm_iter++) {
-              if (uWfm.at(wfm_iter) > uHitAmlpitude) uHitAmlpitude = uWfm.at(wfm_iter);
-              uHitChargeWfm += uWfm.at(wfm_iter) - uZeroLevel;
-              if (fbMonitorWfmMode) fvhHitWfmChan[uHitChannel]->Fill(wfm_iter, uWfm.at(wfm_iter));
+
+            if(!uWfm.empty()){
+              iHitChargeWfm = std::accumulate(uWfm.begin(), uWfm.end(), 0);
+              iHitChargeWfm -= uZeroLevel*uWfm.size();
+
+              auto const max_iter = std::max_element(uWfm.begin(), uWfm.end());
+              assert(max_iter != uWfm.end());
+              if (max_iter == uWfm.end()) break;
+
+              uint8_t hit_time_max = std::distance(uWfm.begin(), max_iter);
+              iHitAmlpitude = *max_iter-uZeroLevel;
+
+              for (UInt_t wfm_iter = 0; wfm_iter < uWfm.size(); wfm_iter++)
+                if (fbMonitorWfmMode) fvhHitWfmChan[uHitChannel]->Fill(wfm_iter, uWfm.at(wfm_iter));
             }
-            uHitAmlpitude -= uZeroLevel;
-            fvhHitAmplChan[uHitChannel]->Fill(uHitAmlpitude);
-            fvhHitChargeByWfmChan[uHitChannel]->Fill(uHitChargeWfm);
+            fvhHitAmplChan[uHitChannel]->Fill(iHitAmlpitude);
+            fvhHitChargeByWfmChan[uHitChannel]->Fill(iHitChargeWfm);
 
             if (fbMonitorWfmMode) {
               fvhHitWfmChan[uHitChannel]->SetTitle(Form("Waveform channel %03u charge %0u zero level %0u; Time [adc "
@@ -447,7 +459,7 @@ Bool_t CbmMcbm2018MonitorAlgoPsd::ProcessMs(const fles::Timeslice& ts,
 
             if (fbMonitorFitMode) {
               int gate_beg = 0;
-              int gate_end = 7;
+              int gate_end = uWfm.size()-1;
               PsdSignalFitting::PronyFitter Pfitter(2, 2, gate_beg, gate_end);
 
               Pfitter.SetDebugMode(0);
@@ -480,18 +492,16 @@ Bool_t CbmMcbm2018MonitorAlgoPsd::ProcessMs(const fles::Timeslice& ts,
           }    //if (fbMonitorChanMode)
 
         }  // for(int hit_iter = 0; hit_iter < PsdReader.EvHdrAb.uHitsNumber; hit_iter++)
-
       } else if (ReadResult == 1) {
-        LOG(error) << "no event headers in message!";
+        LOG(error) << "no pack headers in message!";
         break;
       } else if (ReadResult == 2) {
-        LOG(error) << "check number of waveform points! In header: "
-                   << PsdReader.HitHdr.uWfmPoints << " should be: " << 8;
+        LOG(error) << "wrong channel! In header: "
+                   << PsdReader.HitHdr.uHitChannel;
         break;
       } else if (ReadResult == 3) {
-        LOG(error) << "wrong amount of hits read! In header: "
-                   << PsdReader.EvHdrAb.uHitsNumber
-                   << " in hit vector: " << PsdReader.VectHitHdr.size();
+        LOG(error) << "check number of waveform points! In header: "
+                   << PsdReader.HitHdr.uWfmWords-1 << " should be: LE " << 8;
         break;
       } else {
         LOG(error)
@@ -520,16 +530,16 @@ Bool_t CbmMcbm2018MonitorAlgoPsd::ProcessMs(const fles::Timeslice& ts,
       }
     }
 
-    if (fulCurrentMsIdx != PsdReader.EvHdrAb.ulMicroSlice)
+    if (fulCurrentMsIdx != PsdReader.MsHdr.ulMicroSlice)
       LOG(error) << "Wrong MS index!"
                  << " in microslice " << fulCurrentMsIdx << " by PsdReader "
-                 << PsdReader.EvHdrAb.ulMicroSlice << "\n";
+                 << PsdReader.MsHdr.ulMicroSlice << "\n";
 
     fuMsgsCntInMs += uNbMessages;
     fuReadMsgsCntInMs += PsdReader.GetTotalGbtWordsRead();
     fuLostMsgsCntInMs += uNbMessages - PsdReader.GetTotalGbtWordsRead();
 
-  }  //if(uSize != 0)
+  }  //if(uSize > 1)
 
   if (fdPrevMsTime < 0.)
     fdPrevMsTime = fdMsTime;
diff --git a/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.h b/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.h
index 15a18e82..d9abac39 100644
--- a/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.h
+++ b/fles/mcbm2018/monitor/CbmMcbm2018MonitorAlgoPsd.h
@@ -24,6 +24,7 @@
 // C/C++
 #include <map>
 #include <vector>
+#include <numeric>
 
 class CbmMcbm2018PsdPar;
 class TH1;
diff --git a/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.cxx b/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.cxx
index 6061e880..42bba122 100644
--- a/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.cxx
+++ b/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.cxx
@@ -123,7 +123,7 @@ Bool_t CbmMcbm2018UnpackerAlgoPsd::InitParameters() {
   fuNrOfGbtx = fUnpackPar->GetNrOfGbtx();
   LOG(info) << "Nr. of GBTx: " << fuNrOfGbtx;
 
-  //Temporary until creation of full psd map
+  //FIXME Temporary until creation of full psd map
   UInt_t uNrOfModules  = 1;
   UInt_t uNrOfSections = 32;
   UInt_t uNrOfChannels = uNrOfModules * uNrOfSections;
@@ -192,7 +192,7 @@ Bool_t CbmMcbm2018UnpackerAlgoPsd::ProcessTs(const fles::Timeslice& ts) {
   //      LOG(info) << Form( "TS %5d Start %12f Stop %12f", fulCurrentTsIdx, fdTsStartTime, fdTsStopTimeCore );
 
   /// Loop over core microslices (and overlap ones if chosen)
-  for (fuMsIndex = 0; fuMsIndex < fuNbMsLoop; fuMsIndex++) {
+  //for (fuMsIndex = 0; fuMsIndex < fuNbMsLoop; fuMsIndex++) {  //TODO uncoment me!
     /// Loop over registered components
     for (UInt_t uMsCompIdx = 0; uMsCompIdx < fvMsComponentsList.size();
          ++uMsCompIdx) {
@@ -204,7 +204,7 @@ Bool_t CbmMcbm2018UnpackerAlgoPsd::ProcessTs(const fles::Timeslice& ts) {
         return kFALSE;
       }  // if( kFALSE == ProcessMs( ts, uMsCompIdx, fuMsIndex ) )
     }  // for( UInt_t uMsCompIdx = 0; uMsCompIdx < fvMsComponentsList.size(); ++uMsCompIdx )
-  }    // for( fuMsIndex = 0; fuMsIndex < uNbMsLoop; fuMsIndex ++ )
+  //}    // for( fuMsIndex = 0; fuMsIndex < uNbMsLoop; fuMsIndex ++ )  //TODO uncoment me!
 
   /// Sort the buffers of hits due to the time offsets applied
   std::sort(fDigiVect.begin(),
@@ -287,79 +287,126 @@ Bool_t CbmMcbm2018UnpackerAlgoPsd::ProcessMs(const fles::Timeslice& ts,
   uint32_t uNbMessages =
     (uSize - (uSize % kuBytesPerMessage)) / kuBytesPerMessage;
 
-  // Prepare variables for the loop on contents
-  const uint64_t* pInBuff = reinterpret_cast<const uint64_t*>(msContent);
 
-  PsdData::PsdGbtReader PsdReader(pInBuff);
-  //PsdReader.SetPrintOutMode(true);
-  if (uSize != 0) {
+
+
+    const uint16_t total_words = 150;
+    uint64_t* pInBuff = new uint64_t[2*total_words];
+    for(int i =0; i < 2*total_words; i++)
+      pInBuff[i] = 0;
+
+   uNbMessages = 2*total_words;
+
+    std::string filename = "/mnt/inr/dry24_cosmic/readout.tsa";
+
+    FILE *DataFile;
+    DataFile = fopen(filename.data(), "rb"); 
+    if(DataFile == NULL){
+		printf("file was NOT opened: %s\n", filename.data());
+	return 0;
+    };
+	printf("\nReading GBT data from file: %s\n\n", filename.data());
+		
+
+    //memset(DataFile, 0, sizeof(DataFile));
+    //int Event_size = 10;
+    //fseek(DataFile, (eventn)*Event_size, SEEK_SET);
+
+	int buf_iter = 0;
+    //for(long line_iter = 0; line_iter < 50 ; line_iter++)    
+    for(long line_iter = 0; (!feof(DataFile)) ; line_iter++)
+    {
+
+		uint64_t flim_buffer[2] = {0}; 
+		std::memset(flim_buffer, 0, sizeof flim_buffer);
+		int read_result = fread(flim_buffer, sizeof(flim_buffer[0]), 2, DataFile);
+
+		if(read_result == 2){
+			printf(" -> %016lx and %016lx", flim_buffer[0], flim_buffer[1]);
+			printf("\n");
+
+			pInBuff[buf_iter] = flim_buffer[0];
+			buf_iter++;
+			pInBuff[buf_iter] = flim_buffer[1];
+			buf_iter++;
+		}
+
+		std::memset(flim_buffer, 0, sizeof flim_buffer);
+    }
+    fclose(DataFile);
+
+
+
+
+
+   // for(int i =0; i < 2*total_words; i++) printf("%016lx\n", pInBuff[i]);
+
+  PsdData::PsdGbtReader PsdReader(pInBuff, 1);
+  if (fair::Logger::Logging(fair::Severity::debug)) PsdReader.SetPrintOutMode(true);
+  // every 80bit gbt word is decomposed into two 64bit words
+  if (uSize > 1) { 
     while (PsdReader.GetTotalGbtWordsRead() < uNbMessages) {
-      int ReadResult = PsdReader.ReadEventFles();
-      if (PsdReader.EvHdrAb.uHitsNumber > fviPsdChUId.size()) {
-        LOG(error) << "too many triggered channels! In header: "
-                   << PsdReader.EvHdrAb.uHitsNumber
-                   << " in PSD: " << fviPsdChUId.size();
-        break;
-      }
+      int ReadResult = PsdReader.ReadMs();
 
       if (ReadResult == 0) {
         //hit loop
-        for (int hit_iter = 0; hit_iter < PsdReader.EvHdrAb.uHitsNumber;
-             hit_iter++) {
-          UInt_t uHitChannel = PsdReader.VectHitHdr.at(hit_iter).uHitChannel;
-          UInt_t uSignalCharge =
-            PsdReader.VectHitHdr.at(hit_iter).uSignalCharge;
-          UInt_t uZeroLevel = PsdReader.VectHitHdr.at(hit_iter).uZeroLevel;
+        for (uint64_t hit_iter = 0; hit_iter < PsdReader.VectHitHdr.size(); hit_iter++) {
+          if(PsdReader.VectPackHdr.size() != PsdReader.VectHitHdr.size()){
+          LOG(error) << "Different vector headers sizes!"
+                     << " in VectPackHdr " << PsdReader.VectPackHdr.size() 
+                     << " in VectHitHdr " << PsdReader.VectHitHdr.size() << "\n";
+            break;
+          }
+
+          uint8_t uHitChannel = PsdReader.VectHitHdr.at(hit_iter).uHitChannel;
+          uint8_t uLinkIndex = PsdReader.VectPackHdr.at(hit_iter).uLinkIndex;
+          uint32_t uSignalCharge = PsdReader.VectHitHdr.at(hit_iter).uSignalCharge;
+          uint16_t uZeroLevel = PsdReader.VectHitHdr.at(hit_iter).uZeroLevel;
+          //double dHitTime = (double) fulCurrentMsIdx + PsdReader.VectPackHdr.at(hit_iter).uAdcTime*12.5; //in ns
+          double dHitTime = PsdReader.MsHdr.ulMicroSlice*1000. + PsdReader.VectPackHdr.at(hit_iter).uAdcTime*12.5; //in ns
           std::vector<uint16_t> uWfm = PsdReader.VectHitData.at(hit_iter).uWfm;
 
+          int32_t iHitAmlpitude = 0;
+          int32_t iHitChargeWfm = 0;
+          if(!uWfm.empty()){
+            iHitChargeWfm = std::accumulate(uWfm.begin(), uWfm.end(), 0);
+            iHitChargeWfm -= uZeroLevel*uWfm.size();
+
+            auto const max_iter = std::max_element(uWfm.begin(), uWfm.end());
+            assert(max_iter != uWfm.end());
+            if (max_iter == uWfm.end()) break;
+
+            uint8_t hit_time_max = std::distance(uWfm.begin(), max_iter);
+            iHitAmlpitude = *max_iter-uZeroLevel;
+          }
+
           if (uHitChannel >= fviPsdChUId.size()) {
             LOG(error) << "hit channel number out of range! channel index: "
                        << uHitChannel << " max: " << fviPsdChUId.size();
             break;
           }
 
-          UInt_t uChId    = uHitChannel;
-          UInt_t uRpdChId = uChId;                  //Should be map(uChId) TODO
-          UInt_t uChanUId = fviPsdChUId[uRpdChId];  //unique ID
+          uint8_t uChId    = uHitChannel;
+          uint8_t uRpdChId = uChId;                  //Should be map(uChId) TODO
+          uint8_t uChanUId = fviPsdChUId[uRpdChId];  //unique ID
 
-          UInt_t uHitAmlpitude = 0;
-          UInt_t uHitChargeWfm = 0;
-          for (UInt_t wfm_iter = 0; wfm_iter < uWfm.size(); wfm_iter++) {
-            if (uWfm.at(wfm_iter) > uHitAmlpitude)
-              uHitAmlpitude = uWfm.at(wfm_iter);
-            uHitChargeWfm += uWfm.at(wfm_iter) - uZeroLevel;
-          }
-          uHitAmlpitude -= uZeroLevel;
-
-          //printf("0x%08x %u %u %u %f %f\n", uChanUId, uChId, CbmPsdAddress::GetModuleId(uChanUId), CbmPsdAddress::GetSectionId(uChanUId), (double)PsdReader.VectHitHdr.at(hit_iter).uSignalCharge, (double)PsdReader.EvHdrAc.uAdcTime );
-
-          Double_t dAdcTime = (double) PsdReader.EvHdrAb.ulMicroSlice
-                              + (double) PsdReader.EvHdrAc.uAdcTime * 12.5
-                              - fdTimeOffsetNs;
-
-          LOG(debug) << Form("Insert 0x%08x digi with charge ", uChanUId)
-                     << uSignalCharge
-                     << Form(", at %u,", PsdReader.EvHdrAc.uAdcTime)
-                     << " epoch: " << PsdReader.EvHdrAb.ulMicroSlice;
-
-          fDigiVect.emplace_back(uChanUId, (double) uSignalCharge, dAdcTime);
+          fDigiVect.emplace_back(uChanUId, (double) uSignalCharge, dHitTime);
 
-          fDigiVect.back().SetAmpl(uHitAmlpitude);
-          fDigiVect.back().SetEdepWfm(uHitChargeWfm);
+          fDigiVect.back().SetAmpl(iHitAmlpitude);
+          fDigiVect.back().SetEdepWfm(iHitChargeWfm);
           fDigiVect.back().SetZL(uZeroLevel);
 
         }  // for(int hit_iter = 0; hit_iter < PsdReader.EvHdrAb.uHitsNumber; hit_iter++)
       } else if (ReadResult == 1) {
-        LOG(error) << "no event headers in message!";
+        LOG(error) << "no pack headers in message!";
         break;
       } else if (ReadResult == 2) {
-        LOG(error) << "check number of waveform points! In header: "
-                   << PsdReader.HitHdr.uWfmPoints << " should be: " << 8;
+        LOG(error) << "wrong channel! In header: "
+                   << PsdReader.HitHdr.uHitChannel;
         break;
       } else if (ReadResult == 3) {
-        LOG(error) << "wrong amount of hits read! In header: "
-                   << PsdReader.EvHdrAb.uHitsNumber
-                   << " in hit vector: " << PsdReader.VectHitHdr.size();
+        LOG(error) << "check number of waveform points! In header: "
+                   << PsdReader.HitHdr.uWfmWords-1 << " should be: LE " << 8;
         break;
       } else {
         LOG(error)
@@ -367,6 +414,8 @@ Bool_t CbmMcbm2018UnpackerAlgoPsd::ProcessMs(const fles::Timeslice& ts,
         break;
       }
 
+
+
     }  // while(PsdReader.GetTotalGbtWordsRead()<uNbMessages)
 
     if (uNbMessages != PsdReader.GetTotalGbtWordsRead())
@@ -374,10 +423,10 @@ Bool_t CbmMcbm2018UnpackerAlgoPsd::ProcessMs(const fles::Timeslice& ts,
                  << " in microslice " << uNbMessages << " by PsdReader "
                  << PsdReader.GetTotalGbtWordsRead() << "\n";
 
-    if (fulCurrentMsIdx != PsdReader.EvHdrAb.ulMicroSlice)
+    if (fulCurrentMsIdx != PsdReader.MsHdr.ulMicroSlice)
       LOG(error) << "Wrong MS index!"
                  << " in microslice " << fulCurrentMsIdx << " by PsdReader "
-                 << PsdReader.EvHdrAb.ulMicroSlice << "\n";
+                 << PsdReader.MsHdr.ulMicroSlice << "\n";
 
   }  //if(uSize != 0)
 
diff --git a/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.h b/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.h
index 07f682d8..010bbdc1 100644
--- a/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.h
+++ b/fles/mcbm2018/unpacker/CbmMcbm2018UnpackerAlgoPsd.h
@@ -24,6 +24,7 @@
 // C/C++
 #include <map>
 #include <vector>
+#include <numeric>
 
 class CbmMcbm2018PsdPar;
 
diff --git a/macro/beamtime/mcbm2020/unpack_tsa_mcbm.C b/macro/beamtime/mcbm2020/unpack_tsa_mcbm.C
index aadd7491..8d6b211a 100644
--- a/macro/beamtime/mcbm2020/unpack_tsa_mcbm.C
+++ b/macro/beamtime/mcbm2020/unpack_tsa_mcbm.C
@@ -599,7 +599,7 @@ Bool_t unpack_tsa_mcbm(TString inFile       = "",
   source->SetWriteOutputFlag(kTRUE);  // For writing TS metadata
 
   source->SetFileName(inFile);
-
+/*
   source->AddUnpacker(unpacker_sts, 0x10, ECbmModuleId::kSts);    // STS xyter
   source->AddUnpacker(unpacker_much, 0x50, ECbmModuleId::kMuch);  // MUCH xyter
   if (isActiveTrd)
@@ -607,7 +607,7 @@ Bool_t unpack_tsa_mcbm(TString inFile       = "",
   source->AddUnpacker(unpacker_tof, 0x60, ECbmModuleId::kTof);     // gDPB TOF
   source->AddUnpacker(unpacker_tof, 0x90, ECbmModuleId::kTof);     // gDPB T0
   source->AddUnpacker(unpacker_rich, 0x30, ECbmModuleId::kRich);   // RICH trb
-  source->AddUnpacker(unpacker_psd, 0x80, ECbmModuleId::kPsd);     // PSD
+*/  source->AddUnpacker(unpacker_psd, 0x80, ECbmModuleId::kPsd);     // PSD
 
   /// Select a pre-identified spills block through block index + block length (in spills)
   /// Also select where we split the spills: beginning, middle or end of the spill break
